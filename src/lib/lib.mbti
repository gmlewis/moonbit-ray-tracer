package "gmlewis/ray-tracer/lib"

import(
  "gmlewis/image"
)

// Values
const EPSILON : Double = 0.00001

fn abs(Tuple) -> Tuple

fn add_child(Shape, Shape) -> Unit

let black : Color

fn camera(Int, Int, Double) -> Camera

fn canvas(Int, Int) -> Canvas

fn checkers_pattern(Array[Color]) -> Pattern

fn children(Shape) -> Array[Shape]

fn clear(Canvas, Color) -> Unit

fn clone(Color) -> Color

fn cofactor(Matrix, Int, Int) -> Double

fn color(Double, Double, Double) -> Color

fn color_at(World, Ray, remaining~ : Int = ..) -> Color

fn cone(minimum~ : Double = .., maximum~ : Double = .., closed~ : Bool = ..) -> Shape

fn copy(Matrix, Matrix) -> Unit

fn cross(Tuple, Tuple) -> Tuple

fn csg(Operation, Shape, Shape) -> Shape

fn cube() -> Shape

fn cylinder(minimum~ : Double = .., maximum~ : Double = .., closed~ : Bool = ..) -> Shape

fn default_world() -> World

fn determinant(Matrix) -> Double

fn div_scalar(Tuple, Double) -> Tuple

fn dot(Tuple, Tuple) -> Double

fn dump(Matrix) -> String

fn enlarge(Bounds, Bounds) -> Unit

fn filter_intersections(CSG, Intersections) -> Intersections

fn glass_sphere() -> Shape

fn gradient_checkers_pattern(Array[Color]) -> Pattern

fn gradient_pattern(Array[Color]) -> Pattern

fn gradient_ring_pattern(Array[Color]) -> Pattern

fn group() -> Shape

fn hit(Intersections) -> Intersection?

fn includes_shape(Shape, Shape) -> Bool

fn intersect(Shape, Ray) -> Intersections

fn intersect_world(World, Ray) -> Intersections

fn intersection(Double, Shape, u~ : Double = .., v~ : Double = ..) -> Intersection

fn intersection_allowed(Operation, Bool, Bool, Bool) -> Bool

fn intersections(Array[Intersection]) -> Intersections

fn inverse(Matrix) -> Matrix

fn is_invertible(Matrix) -> Bool

fn is_point(Tuple) -> Bool

fn is_shadowed(World, Tuple, light? : Light) -> Bool

fn is_vector(Tuple) -> Bool

fn lighting(Material, Light, Tuple, Tuple, Tuple, in_shadow~ : Bool = .., shape~ : Shape? = ..) -> Color

fn local_intersect(Bounds, Ray, Shape) -> Intersections

fn magnitude(Tuple) -> Double

fn mat2(Double, Double, Double, Double) -> Matrix

fn mat3(Double, Double, Double, Double, Double, Double, Double, Double, Double) -> Matrix

fn mat4(Double, Double, Double, Double, Double, Double, Double, Double, Double, Double, Double, Double, Double, Double, Double, Double) -> Matrix

fn mat4ident() -> Matrix

fn mat4zero() -> Matrix

fn material() -> Material

fn minor(Matrix, Int, Int) -> Double

fn mul_scalar(Color, Double) -> Color

fn mul_tuple(Matrix, Tuple) -> Tuple

fn normal_at(Shape, Tuple, hit~ : Intersection? = ..) -> Tuple

fn normal_to_world(Shape, Tuple) -> Tuple

fn normalize(Tuple) -> Tuple

fn num_cols(Matrix) -> Int

fn num_rows(Matrix) -> Int

fn obj_to_group(ObjFile) -> Shape

fn op_div(Tuple, Tuple) -> Tuple

fn op_get(Intersections, Int) -> Intersection

fn op_set(MatrixRow, Int, Double) -> Unit

fn parse_obj_file(String) -> ObjFile raise ParserError

fn pattern_at_shape(Pattern, Shape, Tuple) -> Color

fn pixel_at(Canvas, Int, Int) -> Color

fn plane() -> Shape

fn point(Double, Double, Double) -> Tuple

fn point_light(Tuple, Color) -> Light

fn position(Ray, Double) -> Tuple

fn prepare_computations(Intersection, Ray, xs? : Intersections) -> Computations

fn ray(Tuple, Tuple) -> Ray

fn ray_for_pixel(Camera, Int, Int) -> Ray

fn reflect(Tuple, Tuple) -> Tuple

fn reflected_color(World, Computations, Int) -> Color

fn refracted_color(World, Computations, Int) -> Color

fn render(Camera, World) -> Canvas

fn ring_pattern(Array[Color]) -> Pattern

fn rotate_x(Matrix, Double) -> Matrix

fn rotate_y(Matrix, Double) -> Matrix

fn rotate_z(Matrix, Double) -> Matrix

fn rotation_x(Double) -> Matrix

fn rotation_y(Double) -> Matrix

fn rotation_z(Double) -> Matrix

fn round_to_fixed(Double, Int) -> Double

fn scale(Matrix, Double, Double, Double) -> Matrix

fn scaling(Double, Double, Double) -> Matrix

fn schlick(Computations) -> Double

fn set_pattern_transform(Pattern, Matrix) -> Unit

fn set_transform(Shape, Matrix) -> Unit

fn shade_hit(World, Computations, remaining~ : Int = ..) -> Color

fn shear(Matrix, Double, Double, Double, Double, Double, Double) -> Matrix

fn shearing(Double, Double, Double, Double, Double, Double) -> Matrix

fn smooth_triangle(Tuple, Tuple, Tuple, Tuple, Tuple, Tuple) -> Shape

fn sphere() -> Shape

fn stripe_pattern(Array[Color]) -> Pattern

fn submatrix(Matrix, Int, Int) -> Matrix

fn to_png(Canvas) -> Bytes raise @image.SizeError

fn to_ppm(Canvas) -> String

fn to_string(Color) -> String

fn to_ts(Intersections) -> Array[Double]

fn transform(Bounds, Matrix) -> Bounds

fn translate(Matrix, Double, Double, Double) -> Matrix

fn translation(Double, Double, Double) -> Matrix

fn transpose(Matrix) -> Matrix

fn triangle(Tuple, Tuple, Tuple) -> Shape

fn tuple(Double, Double, Double, Double) -> Tuple

fn update(Bounds, Tuple) -> Unit

fn vector(Double, Double, Double) -> Tuple

fn view_transform(Tuple, Tuple, Tuple) -> Matrix

let white : Color

fn world() -> World

fn world_to_object(Shape, Tuple) -> Tuple

fn write_pixel(Canvas, Int, Int, Color) -> Unit

// Types and methods
pub(all) struct Bounds {
  mut min : Tuple
  mut max : Tuple
}
fn Bounds::enlarge(Self, Self) -> Unit
fn Bounds::local_intersect(Self, Ray, Shape) -> Intersections
fn Bounds::new() -> Self
fn Bounds::transform(Self, Matrix) -> Self
fn Bounds::update(Self, Tuple) -> Unit
impl Eq for Bounds
impl Show for Bounds

pub(all) struct CSG {
  operation : Operation
  left : Shape
  right : Shape
}
fn CSG::filter_intersections(Self, Intersections) -> Intersections
impl Eq for CSG
impl Show for CSG

pub(all) struct Camera {
  hsize : Int
  vsize : Int
  field_of_view : Double
  mut transform : Matrix
  pixel_size : Double
  half_width : Double
  half_height : Double
}
fn Camera::ray_for_pixel(Self, Int, Int) -> Ray
fn Camera::render(Self, World) -> Canvas
impl Eq for Camera
impl Show for Camera

pub(all) struct Canvas {
  width : Int
  height : Int
  red : Array[Double]
  green : Array[Double]
  blue : Array[Double]
}
fn Canvas::clear(Self, Color) -> Unit
fn Canvas::pixel_at(Self, Int, Int) -> Color
fn Canvas::to_png(Self) -> Bytes raise @image.SizeError
fn Canvas::to_ppm(Self) -> String
fn Canvas::write_pixel(Self, Int, Int, Color) -> Unit

pub(all) struct CheckersPattern {
  colors : Array[Color]
}
fn CheckersPattern::to_string(Self) -> String
impl PatternTrait for CheckersPattern
impl Eq for CheckersPattern
impl Show for CheckersPattern

pub(all) struct Color {
  red : Double
  green : Double
  blue : Double
}
fn Color::clone(Self) -> Self
fn Color::mul_scalar(Self, Double) -> Self
fn Color::to_string(Self) -> String
impl Add for Color
impl Eq for Color
impl Mul for Color
impl Show for Color
impl Sub for Color

pub(all) struct Computations {
  t : Double
  shape : Shape
  point : Tuple
  eyev : Tuple
  normalv : Tuple
  reflectv : Tuple
  inside : Bool
  over_point : Tuple
  under_point : Tuple
  n1 : Double
  n2 : Double
}
fn Computations::schlick(Self) -> Double

pub(all) struct Cone {
  minimum : Double
  maximum : Double
  closed : Bool
}
impl Object for Cone
impl Eq for Cone
impl Show for Cone

pub(all) struct Cube {
}
impl Object for Cube
impl Eq for Cube
impl Show for Cube

pub(all) struct Cylinder {
  minimum : Double
  maximum : Double
  closed : Bool
}
impl Object for Cylinder
impl Eq for Cylinder
impl Show for Cylinder

pub(all) struct GradientCheckersPattern {
  colors : Array[Color]
}
fn GradientCheckersPattern::to_string(Self) -> String
impl PatternTrait for GradientCheckersPattern
impl Eq for GradientCheckersPattern
impl Show for GradientCheckersPattern

pub(all) struct GradientPattern {
  colors : Array[Color]
}
fn GradientPattern::to_string(Self) -> String
impl PatternTrait for GradientPattern
impl Eq for GradientPattern
impl Show for GradientPattern

pub(all) struct GradientRingPattern {
  colors : Array[Color]
}
fn GradientRingPattern::to_string(Self) -> String
impl PatternTrait for GradientRingPattern
impl Eq for GradientRingPattern
impl Show for GradientRingPattern

pub(all) struct Group {
  children : Array[Shape]
  mut bounds : Bounds?
}
fn Group::bounds(Self) -> Bounds
fn Group::local_intersect(Self, Shape, Ray) -> Intersections
fn Group::local_normal_at(Self, Tuple) -> Tuple
fn Group::output(Self, &Logger) -> Unit
fn Group::to_string(Self) -> String

pub(all) struct Intersection {
  t : Double
  shape : Shape
  u : Double
  v : Double
}
fn Intersection::prepare_computations(Self, Ray, xs? : Intersections) -> Computations
fn Intersection::to_string(Self) -> String
impl Eq for Intersection
impl Show for Intersection

pub(all) struct Intersections {
  count : Int
  xs : Array[Intersection]
  hit : Intersection?
}
fn Intersections::from_ts(Array[Double], Shape) -> Self
fn Intersections::hit(Self) -> Intersection?
fn Intersections::op_get(Self, Int) -> Intersection
fn Intersections::to_ts(Self) -> Array[Double]

pub(all) struct Light {
  position : Tuple
  intensity : Color
}
impl Eq for Light
impl Show for Light

pub(all) struct Material {
  mut color : Color
  mut ambient : Double
  mut diffuse : Double
  mut specular : Double
  mut shininess : Double
  mut reflective : Double
  mut transparency : Double
  mut refractive_index : Double
  mut pattern : Pattern?
}
fn Material::lighting(Self, Light, Tuple, Tuple, Tuple, in_shadow~ : Bool = .., shape~ : Shape? = ..) -> Color
impl Eq for Material
impl Show for Material

pub(all) type Matrix Array[MatrixRow]
fn Matrix::clone(Self) -> Self
fn Matrix::cofactor(Self, Int, Int) -> Double
fn Matrix::copy(Self, Self) -> Unit
fn Matrix::determinant(Self) -> Double
fn Matrix::dump(Self) -> String
fn Matrix::inverse(Self) -> Self
fn Matrix::is_invertible(Self) -> Bool
fn Matrix::minor(Self, Int, Int) -> Double
fn Matrix::mul_tuple(Self, Tuple) -> Tuple
fn Matrix::num_cols(Self) -> Int
fn Matrix::num_rows(Self) -> Int
fn Matrix::op_get(Self, Int) -> MatrixRow
fn Matrix::rotate_x(Self, Double) -> Self
fn Matrix::rotate_y(Self, Double) -> Self
fn Matrix::rotate_z(Self, Double) -> Self
fn Matrix::scale(Self, Double, Double, Double) -> Self
fn Matrix::shear(Self, Double, Double, Double, Double, Double, Double) -> Self
fn Matrix::submatrix(Self, Int, Int) -> Self
fn Matrix::to_string(Self) -> String
fn Matrix::translate(Self, Double, Double, Double) -> Self
fn Matrix::transpose(Self) -> Self
impl Eq for Matrix
impl Mul for Matrix
impl Show for Matrix

pub(all) type MatrixRow Array[Double]
fn MatrixRow::op_get(Self, Int) -> Double
fn MatrixRow::op_set(Self, Int, Double) -> Unit
impl Show for MatrixRow

pub(all) struct ObjFile {
  default_group : Shape
  ignored_lines : Int
  vertices : Array[Tuple]
  normals : Array[Tuple]
  named_groups : Map[String, Shape]
}
fn ObjFile::obj_to_group(Self) -> Shape

pub(all) enum Operation {
  Union
  Intersection
  Difference
}
impl Eq for Operation
impl Show for Operation

type ParserError
impl Eq for ParserError
impl Show for ParserError

pub(all) struct Pattern {
  pattern : &PatternTrait
  mut transform : Matrix
  mut inv_transform : Matrix
}
fn Pattern::new(&PatternTrait) -> Self
fn Pattern::pattern_at_shape(Self, Shape, Tuple) -> Color
fn Pattern::set_pattern_transform(Self, Matrix) -> Unit
impl PatternTrait for Pattern
impl Eq for Pattern
impl Show for Pattern

pub(all) struct Plane {
}
impl Object for Plane
impl Eq for Plane
impl Show for Plane

pub(all) struct Ray {
  origin : Tuple
  direction : Tuple
}
fn Ray::position(Self, Double) -> Tuple
fn Ray::transform(Self, Matrix) -> Self
impl Eq for Ray
impl Show for Ray

pub(all) enum Renderable {
  Object(&Object)
  Group(Group)
  Triangle(Triangle)
  SmoothTriangle(SmoothTriangle)
  CSG(CSG)
}
impl Show for Renderable

pub(all) struct RingPattern {
  colors : Array[Color]
}
fn RingPattern::to_string(Self) -> String
impl PatternTrait for RingPattern
impl Eq for RingPattern
impl Show for RingPattern

pub(all) struct Shape {
  object : Renderable
  mut material : Material
  mut transform : Matrix
  mut inv_transform : Matrix
  mut parent : Shape?
  mut bounds : Bounds?
  id : UInt
}
fn Shape::add_child(Self, Self) -> Unit
fn Shape::bounds(Self) -> Bounds
fn Shape::children(Self) -> Array[Self]
fn Shape::includes_shape(Self, Self) -> Bool
fn Shape::intersect(Self, Ray) -> Intersections
fn Shape::local_intersect(Self, Ray) -> Intersections
fn Shape::local_normal_at(Self, Tuple, hit~ : Intersection? = ..) -> Tuple
fn Shape::new(Renderable) -> Self
fn Shape::new_csg(CSG) -> Self
fn Shape::new_group(Group) -> Self
fn Shape::new_object(&Object) -> Self
fn Shape::new_smooth_triangle(SmoothTriangle) -> Self
fn Shape::new_triangle(Triangle) -> Self
fn Shape::normal_at(Self, Tuple, hit~ : Intersection? = ..) -> Tuple
fn Shape::normal_to_world(Self, Tuple) -> Tuple
fn Shape::set_transform(Self, Matrix) -> Unit
fn Shape::world_to_object(Self, Tuple) -> Tuple
impl Eq for Shape
impl Show for Shape

pub(all) struct SmoothTriangle {
  p1 : Tuple
  p2 : Tuple
  p3 : Tuple
  n1 : Tuple
  n2 : Tuple
  n3 : Tuple
  e1 : Tuple
  e2 : Tuple
  bounds : Bounds
}
fn SmoothTriangle::bounds(Self) -> Bounds
fn SmoothTriangle::local_intersect(Self, Ray) -> Array[(Double, Double, Double)]
fn SmoothTriangle::local_normal_at(Self, Tuple, Intersection) -> Tuple
impl Eq for SmoothTriangle
impl Show for SmoothTriangle

pub(all) struct Sphere {
}
impl Object for Sphere
impl Eq for Sphere
impl Show for Sphere

pub(all) struct StripePattern {
  colors : Array[Color]
}
fn StripePattern::to_string(Self) -> String
impl PatternTrait for StripePattern
impl Eq for StripePattern
impl Show for StripePattern

pub(all) struct Triangle {
  p1 : Tuple
  p2 : Tuple
  p3 : Tuple
  e1 : Tuple
  e2 : Tuple
  normal : Tuple
  bounds : Bounds
}
fn Triangle::bounds(Self) -> Bounds
fn Triangle::local_intersect(Self, Ray) -> Array[(Double, Double, Double)]
fn Triangle::local_normal_at(Self, Tuple) -> Tuple
impl Eq for Triangle
impl Show for Triangle

pub(all) struct Tuple {
  mut x : Double
  mut y : Double
  mut z : Double
  mut w : Double
}
fn Tuple::abs(Self) -> Self
fn Tuple::cross(Self, Self) -> Self
fn Tuple::div_scalar(Self, Double) -> Self
fn Tuple::dot(Self, Self) -> Double
fn Tuple::is_point(Self) -> Bool
fn Tuple::is_vector(Self) -> Bool
fn Tuple::magnitude(Self) -> Double
fn Tuple::mul_scalar(Self, Double) -> Self
fn Tuple::normalize(Self) -> Self
fn Tuple::op_div(Self, Self) -> Self
fn Tuple::op_get(Self, Int) -> Double
fn Tuple::op_set(Self, Int, Double) -> Unit
fn Tuple::reflect(Self, Self) -> Self
fn Tuple::to_string(Self) -> String
impl Add for Tuple
impl Eq for Tuple
impl Mul for Tuple
impl Neg for Tuple
impl Show for Tuple
impl Sub for Tuple

pub(all) struct World {
  mut shapes : Array[Shape]
  mut lights : Array[Light]
}
fn World::color_at(Self, Ray, remaining~ : Int = ..) -> Color
fn World::intersect_world(Self, Ray) -> Intersections
fn World::is_shadowed(Self, Tuple, light? : Light) -> Bool
fn World::reflected_color(Self, Computations, Int) -> Color
fn World::refracted_color(Self, Computations, Int) -> Color
fn World::shade_hit(Self, Computations, remaining~ : Int = ..) -> Color

// Type aliases

// Traits
pub(open) trait Object : Show {
  local_intersect(Self, Ray) -> Array[Double]
  local_normal_at(Self, Tuple) -> Tuple
  bounds(Self) -> Bounds
}

pub(open) trait PatternTrait : Show {
  pattern_at(Self, Tuple) -> Color
  clone(Self) -> Pattern
}

