// Generated using `moon info`, DON'T EDIT IT
package "gmlewis/ray-tracer/lib"

import(
  "gmlewis/fonts/draw"
  "gmlewis/fonts/geom"
  "gmlewis/image"
  "gmlewis/ray-tracer/hdr"
)

// Values
pub const EPSILON : Double = 0.00001

pub fn area_light(Tuple, Tuple, Int, Tuple, Int, Color) -> Light

pub fn bias_gain_pattern(Pattern, bias? : Double, gain? : Double) -> Pattern

pub let black : Color

pub fn bump_normal_from_pattern(Pattern, Double, Shape, Tuple, Tuple, uv? : (Double, Double)) -> Tuple

pub fn camera(Int, Int, Double) -> Camera

pub fn canvas(Int, Int) -> Canvas

pub fn checkers_pattern(Array[Color]) -> Pattern

pub fn color(Double, Double, Double) -> Color

pub fn cone(minimum? : Double, maximum? : Double, closed? : Bool) -> Shape

pub fn contrast_pattern(Pattern, contrast? : Double, pivot? : Double) -> Pattern

pub fn csg(Operation, Shape, Shape) -> Shape

pub fn cube() -> Shape

pub fn cubic_map(Tuple) -> (Double, Double)

pub fn cylinder(minimum? : Double, maximum? : Double, closed? : Bool) -> Shape

pub fn cylindrical_map(Tuple) -> (Double, Double)

pub fn decode_base64_uri(String) -> Bytes?

pub fn default_world() -> World

pub fn fbm3(Tuple, Int, Int, Double, Double) -> Double

pub fn fbm_pattern(seed? : Int, scale? : Double, octaves? : Int, lacunarity? : Double, gain? : Double) -> Pattern

pub fn field(Pattern, vector_decoding? : VectorDecoding) -> Field

pub fn field_signed(Pattern) -> Field

pub fn field_unit01(Pattern) -> Field

pub fn get_directory(String) -> String

pub fn glass_sphere() -> Shape

pub fn gradient_checkers_pattern(Array[Color]) -> Pattern

pub fn gradient_map_pattern(Pattern, Array[Color]) -> Pattern

pub fn gradient_pattern(Array[Color]) -> Pattern

pub fn gradient_ring_pattern(Array[Color]) -> Pattern

pub fn graphic_mask_pattern(@draw.Graphic, curve_segments? : Int, inside? : Color, outside? : Color, style? : Bool) -> Pattern

pub fn group() -> Shape

pub fn intersection(Double, Shape, u? : Double, v? : Double) -> Intersection

pub fn intersection_allowed(Operation, Bool, Bool, Bool) -> Bool

pub fn intersections(Array[Intersection]) -> Intersections

pub fn invert_pattern(Pattern) -> Pattern

pub fn levels_pattern(Pattern, in_min? : Double, in_max? : Double, out_min? : Double, out_max? : Double, gamma? : Double) -> Pattern

pub async fn load_gltf_file(String) -> Shape raise SceneParseError

pub fn marble_pattern(Array[Color], seed? : Int, scale? : Double, octaves? : Int, lacunarity? : Double, gain? : Double, frequency? : Double, strength? : Double) -> Pattern

pub fn mat2(Double, Double, Double, Double) -> Matrix

pub fn mat3(Double, Double, Double, Double, Double, Double, Double, Double, Double) -> Matrix

pub fn mat4(Double, Double, Double, Double, Double, Double, Double, Double, Double, Double, Double, Double, Double, Double, Double, Double) -> Matrix

pub fn mat4ident() -> Matrix

pub fn mat4zero() -> Matrix

pub fn material() -> Material

pub fn mix_pattern(Pattern, Pattern, Pattern) -> Pattern

pub fn noise_pattern(seed? : Int, scale? : Double) -> Pattern

pub fn parse_gltf(Json) -> Gltf?

pub fn parse_obj_file(String) -> ObjFile raise ParserError

pub fn parse_scene(String) -> ParsedScene raise SceneParseError

pub async fn parse_scene_file(String) -> ParsedScene raise SceneParseError

pub fn planar_map(Tuple) -> (Double, Double)

pub fn plane() -> Shape

pub fn point(Double, Double, Double) -> Tuple

pub fn point_light(Tuple, Color) -> Light

pub fn posterize_pattern(Pattern, steps? : Int) -> Pattern

pub fn ray(Tuple, Tuple) -> Ray

pub fn ring_pattern(Array[Color]) -> Pattern

pub fn rotation_x(Double) -> Matrix

pub fn rotation_y(Double) -> Matrix

pub fn rotation_z(Double) -> Matrix

pub fn round_to_fixed(Double, Int) -> Double

pub fn scaling(Double, Double, Double) -> Matrix

pub fn shearing(Double, Double, Double, Double, Double, Double) -> Matrix

pub fn smooth_triangle(Tuple, Tuple, Tuple, Tuple, Tuple, Tuple) -> Shape

pub fn smooth_triangle_uv(Tuple, Tuple, Tuple, Tuple, Tuple, Tuple, (Double, Double), (Double, Double), (Double, Double)) -> Shape

pub fn smooth_triangle_uv_with_extra_uv(Tuple, Tuple, Tuple, Tuple, Tuple, Tuple, (Double, Double), (Double, Double), (Double, Double), (Double, Double), (Double, Double), (Double, Double)) -> Shape

pub fn smooth_triangle_uv_with_tangents(Tuple, Tuple, Tuple, Tuple, Tuple, Tuple, (Double, Double), (Double, Double), (Double, Double), Tuple, Tuple) -> Shape

pub fn smooth_triangle_uv_with_tangents_and_extra_uv(Tuple, Tuple, Tuple, Tuple, Tuple, Tuple, (Double, Double), (Double, Double), (Double, Double), Tuple, Tuple, (Double, Double), (Double, Double), (Double, Double)) -> Shape

pub fn sphere() -> Shape

pub fn spherical_map(Tuple) -> (Double, Double)

pub fn stripe_pattern(Array[Color]) -> Pattern

pub fn texture(Canvas, mapping? : &Mapping) -> Pattern

pub fn threshold_pattern(Pattern, threshold? : Double, low? : Color, high? : Color) -> Pattern

pub fn translation(Double, Double, Double) -> Matrix

pub fn triangle(Tuple, Tuple, Tuple) -> Shape

pub fn triangle_uv(Tuple, Tuple, Tuple, (Double, Double), (Double, Double), (Double, Double)) -> Shape

pub fn triangle_uv_with_extra_uv(Tuple, Tuple, Tuple, (Double, Double), (Double, Double), (Double, Double), (Double, Double), (Double, Double), (Double, Double)) -> Shape

pub fn triangle_uv_with_tangents(Tuple, Tuple, Tuple, (Double, Double), (Double, Double), (Double, Double), Tuple, Tuple) -> Shape

pub fn triangle_uv_with_tangents_and_extra_uv(Tuple, Tuple, Tuple, (Double, Double), (Double, Double), (Double, Double), Tuple, Tuple, (Double, Double), (Double, Double), (Double, Double)) -> Shape

pub fn triplanar_pattern(Pattern, scale? : Double, sharpness? : Double) -> Pattern

pub fn tuple(Double, Double, Double, Double) -> Tuple

pub fn value_noise3(Tuple, Int) -> Double

pub fn vector(Double, Double, Double) -> Tuple

pub fn view_transform(Tuple, Tuple, Tuple) -> Matrix

pub fn voronoi2(Tuple, Int, Double) -> (Double, Int, Int)

pub fn voronoi2_f1_f2(Tuple, Int, Double) -> (Double, Double, Int, Int)

pub fn voronoi_f1_pattern(seed? : Int, scale? : Double, jitter? : Double) -> Pattern

pub fn voronoi_f2_minus_f1_pattern(seed? : Int, scale? : Double, jitter? : Double, edge_scale? : Double) -> Pattern

pub fn voronoi_f2_pattern(seed? : Int, scale? : Double, jitter? : Double) -> Pattern

pub fn voronoi_pattern(seed? : Int, scale? : Double, jitter? : Double, mode? : VoronoiMode, edge_scale? : Double) -> Pattern

pub fn warp_pattern(Pattern, Pattern, amplitude? : Double) -> Pattern

pub let white : Color

pub fn wood_pattern(Array[Color], seed? : Int, scale? : Double, octaves? : Int, lacunarity? : Double, gain? : Double, ring_frequency? : Double, turbulence? : Double) -> Pattern

pub fn world() -> World

// Errors
type ParserError
pub impl Eq for ParserError
pub impl Show for ParserError

pub suberror SceneParseError {
  SceneParseError(String)
}
pub impl Eq for SceneParseError
pub impl Show for SceneParseError

// Types and methods
pub(all) struct BiasGainPattern {
  pattern : Pattern
  bias : Double
  gain : Double
}
pub impl PatternTrait for BiasGainPattern
pub impl Show for BiasGainPattern

pub(all) struct BinaryReader {
  bytes : Bytes
  mut offset : Int
}
pub fn BinaryReader::new(Bytes, offset? : Int) -> Self
pub fn BinaryReader::read_float32(Self) -> Float
pub fn BinaryReader::read_uint16(Self) -> UInt
pub fn BinaryReader::read_uint32(Self) -> UInt
pub fn BinaryReader::read_uint8(Self) -> UInt

pub(all) struct Bounds {
  mut min : Tuple
  mut max : Tuple
}
pub fn Bounds::depth(Self) -> Double
pub fn Bounds::enlarge(Self, Self) -> Unit
pub fn Bounds::height(Self) -> Double
pub fn Bounds::local_intersect(Self, Ray) -> Bool
pub fn Bounds::new() -> Self
pub fn Bounds::transform(Self, Matrix) -> Self
pub fn Bounds::update(Self, Tuple) -> Unit
pub fn Bounds::width(Self) -> Double
pub impl Eq for Bounds
pub impl Show for Bounds

pub(all) struct CSG {
  operation : Operation
  left : Shape
  right : Shape
}
pub fn CSG::clone(Self) -> Self
pub fn CSG::filter_intersections(Self, Intersections) -> Intersections
pub impl Eq for CSG
pub impl Show for CSG

pub(all) struct Camera {
  hsize : Int
  vsize : Int
  field_of_view : Double
  mut transform : Matrix
  pixel_size : Double
  half_width : Double
  half_height : Double
}
pub fn Camera::ray_for_pixel(Self, Int, Int, offset_x? : Double, offset_y? : Double) -> Ray
pub async fn Camera::render(Self, World, samples? : Int, progress? : async (Int) -> Unit) -> Canvas
pub impl Eq for Camera
pub impl Show for Camera

pub(all) struct Canvas {
  width : Int
  height : Int
  red : Array[Double]
  green : Array[Double]
  blue : Array[Double]
  mut exposure : Double
  mut use_tone_mapping : Bool
}
pub fn Canvas::clear(Self, Color) -> Unit
pub fn Canvas::from_hdr(@hdr.HdrImage) -> Self
pub fn Canvas::from_image(&@image.Image, linear? : Bool) -> Self
pub fn Canvas::from_jpeg(Bytes, linear? : Bool) -> Self?
pub fn Canvas::from_png(Bytes, linear? : Bool) -> Self?
pub fn Canvas::pixel_at(Self, Int, Int) -> Color
pub fn Canvas::pixel_at_bilinear(Self, Double, Double) -> Color
pub fn Canvas::to_png(Self) -> Bytes raise @image.SizeError
pub fn Canvas::to_ppm(Self) -> String
pub fn Canvas::write_pixel(Self, Int, Int, Color) -> Unit
pub impl Eq for Canvas
pub impl Show for Canvas

pub(all) struct CheckersPattern {
  colors : Array[Color]
}
pub fn CheckersPattern::to_string(Self) -> String
pub impl PatternTrait for CheckersPattern
pub impl Eq for CheckersPattern
pub impl Show for CheckersPattern

pub(all) struct Color {
  red : Double
  green : Double
  blue : Double
}
pub fn Color::clamp_valid(Self) -> Self
pub fn Color::clone(Self) -> Self
pub fn Color::luminance(Self) -> Double
pub fn Color::mul_scalar(Self, Double) -> Self
pub fn Color::srgb_to_linear(Self) -> Self
pub fn Color::to_string(Self) -> String
pub impl Add for Color
pub impl Eq for Color
pub impl Mul for Color
pub impl Show for Color
pub impl Sub for Color

pub(all) struct Computations {
  t : Double
  shape : Shape
  point : Tuple
  eyev : Tuple
  normalv : Tuple
  reflectv : Tuple
  inside : Bool
  over_point : Tuple
  under_point : Tuple
  n1 : Double
  n2 : Double
  uv_u : Double
  uv_v : Double
  has_uv : Bool
  uv_u1 : Double
  uv_v1 : Double
  has_uv1 : Bool
}
pub fn Computations::schlick(Self) -> Double

pub(all) struct Cone {
  minimum : Double
  maximum : Double
  closed : Bool
}
pub impl Object for Cone
pub impl Eq for Cone
pub impl Show for Cone

pub(all) struct ContrastPattern {
  pattern : Pattern
  contrast : Double
  pivot : Double
}
pub impl PatternTrait for ContrastPattern
pub impl Show for ContrastPattern

pub(all) struct Cube {
}
pub impl Object for Cube
pub impl Eq for Cube
pub impl Show for Cube

pub(all) struct CubicMapping {
}
pub impl Mapping for CubicMapping
pub impl Eq for CubicMapping
pub impl Show for CubicMapping

pub(all) struct Cylinder {
  minimum : Double
  maximum : Double
  closed : Bool
}
pub impl Object for Cylinder
pub impl Eq for Cylinder
pub impl Show for Cylinder

pub(all) struct CylindricalMapping {
}
pub impl Mapping for CylindricalMapping
pub impl Eq for CylindricalMapping
pub impl Show for CylindricalMapping

pub(all) struct FbmPattern {
  seed : Int
  scale : Double
  octaves : Int
  lacunarity : Double
  gain : Double
}
pub impl PatternTrait for FbmPattern
pub impl Eq for FbmPattern
pub impl Show for FbmPattern

pub struct Field {
  pattern : Pattern
  vector_decoding : VectorDecoding
}
pub fn Field::color_at(Self, Tuple) -> Color
pub fn Field::color_at_with_info(Self, Tuple, Tuple, (Double, Double)?) -> Color
pub fn Field::color_uv_at(Self, Double, Double) -> Color
pub fn Field::scalar_at(Self, Tuple) -> Double
pub fn Field::scalar_at_with_info(Self, Tuple, Tuple, (Double, Double)?) -> Double
pub fn Field::scalar_uv_at(Self, Double, Double) -> Double
pub fn Field::vector_at(Self, Tuple) -> Tuple
pub fn Field::vector_at_with_info(Self, Tuple, Tuple, (Double, Double)?) -> Tuple
pub fn Field::vector_uv_at(Self, Double, Double) -> Tuple
pub impl Show for Field

pub(all) struct Gltf {
  accessors : Array[GltfAccessor]
  buffer_views : Array[GltfBufferView]
  buffers : Array[GltfBuffer]
  meshes : Array[GltfMesh]
  nodes : Array[GltfNode]
  scenes : Array[GltfScene]
  scene : Int?
  materials : Array[GltfMaterial]
  textures : Array[GltfTexture]
  images : Array[GltfImage]
}

pub(all) struct GltfAccessor {
  buffer_view : Int?
  byte_offset : Int
  component_type : Int
  count : Int
  max : Array[Double]?
  min : Array[Double]?
  type_ : String
}

pub(all) struct GltfBuffer {
  uri : String?
  byte_length : Int
}

pub(all) struct GltfBufferView {
  buffer : Int
  byte_offset : Int
  byte_length : Int
  byte_stride : Int?
  target : Int?
}

pub(all) struct GltfData {
  gltf : Gltf
  buffers : Array[Bytes]
}
pub fn GltfData::get_accessor_reader(Self, Int) -> (BinaryReader, Int)?
pub fn GltfData::load_material(Self, Int) -> Material
pub fn GltfData::load_material_texture(Self, Int, linear? : Bool) -> Pattern?
pub fn GltfData::load_mesh(Self, Int) -> Shape
pub fn GltfData::load_node(Self, Int) -> Shape
pub fn GltfData::read_indices(Self, Int) -> Array[Int]
pub fn GltfData::read_vec2(Self, Int) -> Array[(Double, Double)]

pub(all) struct GltfImage {
  uri : String?
  buffer_view : Int?
  mime_type : String?
  name : String?
}

pub(all) struct GltfMaterial {
  pbr_metallic_roughness : GltfMaterialPbr?
  normal_texture : GltfNormalTextureInfo?
  occlusion_texture : GltfTextureInfo?
  emissive_texture : GltfTextureInfo?
  emissive_factor : Array[Double]?
  name : String?
}

pub(all) struct GltfMaterialPbr {
  base_color_factor : Array[Double]?
  base_color_texture : GltfTextureInfo?
  metallic_factor : Double?
  roughness_factor : Double?
  metallic_roughness_texture : GltfTextureInfo?
}

pub(all) struct GltfMesh {
  primitives : Array[GltfMeshPrimitive]
  name : String?
}

pub(all) struct GltfMeshPrimitive {
  attributes : Map[String, Int]
  indices : Int?
  material : Int?
  mode : Int
}

pub(all) struct GltfNode {
  mesh : Int?
  children : Array[Int]?
  matrix : Array[Double]?
  translation : Array[Double]?
  rotation : Array[Double]?
  scale : Array[Double]?
  name : String?
}

pub(all) struct GltfNormalTextureInfo {
  index : Int
  tex_coord : Int?
  scale : Double?
}

pub(all) struct GltfScene {
  nodes : Array[Int]
  name : String?
}

pub(all) struct GltfTexture {
  sampler : Int?
  source : Int?
  name : String?
}

pub(all) struct GltfTextureInfo {
  index : Int
  tex_coord : Int?
}

pub(all) struct GradientCheckersPattern {
  colors : Array[Color]
}
pub fn GradientCheckersPattern::to_string(Self) -> String
pub impl PatternTrait for GradientCheckersPattern
pub impl Eq for GradientCheckersPattern
pub impl Show for GradientCheckersPattern

pub(all) struct GradientMapPattern {
  pattern : Pattern
  colors : Array[Color]
}
pub impl PatternTrait for GradientMapPattern
pub impl Show for GradientMapPattern

pub(all) struct GradientPattern {
  colors : Array[Color]
}
pub fn GradientPattern::to_string(Self) -> String
pub impl PatternTrait for GradientPattern
pub impl Eq for GradientPattern
pub impl Show for GradientPattern

pub(all) struct GradientRingPattern {
  colors : Array[Color]
}
pub fn GradientRingPattern::to_string(Self) -> String
pub impl PatternTrait for GradientRingPattern
pub impl Eq for GradientRingPattern
pub impl Show for GradientRingPattern

pub(all) struct GraphicMaskPattern {
  graphic : @draw.Graphic
  profiles : Array[(Array[@geom.Vec2], Array[Array[@geom.Vec2]])]
  overall_bbox : (@geom.Vec2, @geom.Vec2)?
  profile_bboxes : Array[(@geom.Vec2, @geom.Vec2)]
  curve_segments : Int
  inside : Color
  outside : Color
  style : Bool
}
pub impl PatternTrait for GraphicMaskPattern
pub impl Show for GraphicMaskPattern

pub(all) struct Group {
  children : Array[Shape]
  mut bounds : Bounds?
}
pub fn Group::bounds(Self) -> Bounds
pub fn Group::clone(Self) -> Self
pub fn Group::divide(Self, Int) -> Unit
pub fn Group::local_intersect(Self, Shape, Ray) -> Intersections
pub fn Group::local_normal_at(Self, Tuple) -> Tuple
pub fn Group::output(Self, &Logger) -> Unit
pub fn Group::partition_children(Self) -> (Array[Shape], Array[Shape])
pub fn Group::to_string(Self) -> String

pub(all) struct Intersection {
  t : Double
  shape : Shape
  u : Double
  v : Double
  mut uv_u : Double
  mut uv_v : Double
  mut has_uv : Bool
  mut uv_u1 : Double
  mut uv_v1 : Double
  mut has_uv1 : Bool
}
pub fn Intersection::prepare_computations(Self, Ray, xs? : Intersections) -> Computations
pub fn Intersection::to_string(Self) -> String
pub impl Eq for Intersection
pub impl Show for Intersection

pub(all) struct Intersections {
  count : Int
  xs : Array[Intersection]
  hit : Intersection?
}
pub fn Intersections::from_ts(Array[Double], Shape) -> Self
pub fn Intersections::hit(Self) -> Intersection?
pub fn Intersections::op_get(Self, Int) -> Intersection
pub fn Intersections::to_ts(Self) -> Array[Double]

pub(all) struct InvertPattern {
  pattern : Pattern
}
pub impl PatternTrait for InvertPattern
pub impl Show for InvertPattern

pub(all) struct LevelsPattern {
  pattern : Pattern
  in_min : Double
  in_max : Double
  out_min : Double
  out_max : Double
  gamma : Double
}
pub impl PatternTrait for LevelsPattern
pub impl Show for LevelsPattern

pub(all) struct Light {
  position : Tuple
  intensity : Color
  kind : LightKind
}
pub fn Light::point_at(Self, Int, Int) -> Tuple
pub fn Light::samples(Self) -> Int
pub impl Eq for Light
pub impl Show for Light

pub(all) enum LightKind {
  Point
  Area(Tuple, Int, Tuple, Int)
}
pub impl Eq for LightKind
pub impl Show for LightKind

pub(all) enum LightingMode {
  Phong
  PBR
}
pub impl Eq for LightingMode
pub impl Show for LightingMode

pub(all) struct MarblePattern {
  colors : Array[Color]
  seed : Int
  scale : Double
  octaves : Int
  lacunarity : Double
  gain : Double
  frequency : Double
  strength : Double
}
pub impl PatternTrait for MarblePattern
pub impl Show for MarblePattern

pub(all) struct Material {
  mut color : Color
  mut ambient : Double
  mut diffuse : Double
  mut specular : Double
  mut shininess : Double
  mut reflective : Double
  mut transparency : Double
  mut refractive_index : Double
  mut pattern : Pattern?
  mut normal_pattern : Pattern?
  mut normal_strength : Double
  mut displacement_pattern : Pattern?
  mut displacement_strength : Double
  mut normal_texture : Pattern?
  mut normal_texture_scale : Double
  mut normal_texture_texcoord : Int
  mut layer_material : String?
  mut layer_mask : String?
  mut layer_opacity : Double
  mut metallic : Double
  mut roughness : Double
  mut lighting_mode : LightingMode
}
pub fn Material::clone(Self) -> Self
pub fn Material::lighting(Self, Light, Tuple, Tuple, Tuple, in_shadow? : Bool, shape? : Shape?, uv0? : (Double, Double), uv1? : (Double, Double)) -> Color
pub impl Eq for Material
pub impl Show for Material

pub(all) struct MaterialLayer {
  top : Material
  mask : Pattern
  opacity : Double
}
pub impl Eq for MaterialLayer
pub impl Show for MaterialLayer

pub(all) struct Matrix(Array[MatrixRow])
pub fn Matrix::clone(Self) -> Self
pub fn Matrix::cofactor(Self, Int, Int) -> Double
pub fn Matrix::copy(Self, Self) -> Unit
pub fn Matrix::determinant(Self) -> Double
pub fn Matrix::dump(Self) -> String
#deprecated
pub fn Matrix::inner(Self) -> Array[MatrixRow]
pub fn Matrix::inverse(Self) -> Self
pub fn Matrix::is_invertible(Self) -> Bool
pub fn Matrix::minor(Self, Int, Int) -> Double
pub fn Matrix::mul_tuple(Self, Tuple) -> Tuple
pub fn Matrix::num_cols(Self) -> Int
pub fn Matrix::num_rows(Self) -> Int
pub fn Matrix::op_get(Self, Int) -> MatrixRow
pub fn Matrix::rotate_x(Self, Double) -> Self
pub fn Matrix::rotate_y(Self, Double) -> Self
pub fn Matrix::rotate_z(Self, Double) -> Self
pub fn Matrix::scale(Self, Double, Double, Double) -> Self
pub fn Matrix::shear(Self, Double, Double, Double, Double, Double, Double) -> Self
pub fn Matrix::submatrix(Self, Int, Int) -> Self
pub fn Matrix::to_string(Self) -> String
pub fn Matrix::translate(Self, Double, Double, Double) -> Self
pub fn Matrix::transpose(Self) -> Self
pub impl Eq for Matrix
pub impl Mul for Matrix
pub impl Show for Matrix

pub(all) struct MatrixRow(Array[Double])
#deprecated
pub fn MatrixRow::inner(Self) -> Array[Double]
pub fn MatrixRow::op_get(Self, Int) -> Double
pub fn MatrixRow::op_set(Self, Int, Double) -> Unit
pub impl Show for MatrixRow

pub(all) struct MixPattern {
  a : Pattern
  b : Pattern
  mask : Field
}
pub impl PatternTrait for MixPattern
pub impl Show for MixPattern

pub(all) struct NoisePattern {
  seed : Int
  scale : Double
}
pub impl PatternTrait for NoisePattern
pub impl Eq for NoisePattern
pub impl Show for NoisePattern

pub(all) struct ObjFile {
  default_group : Shape
  ignored_lines : Int
  vertices : Array[Tuple]
  normals : Array[Tuple]
  named_groups : Map[String, Shape]
}
pub fn ObjFile::obj_to_group(Self) -> Shape

pub(all) enum Operation {
  Union
  Intersection
  Difference
}
pub impl Eq for Operation
pub impl Show for Operation

pub(all) struct ParsedScene {
  world : World
  camera : Camera
  render_settings : RenderSettings
  metadata : SceneMetadata
  templates : Map[String, Shape]
  graphics : Map[String, @draw.Graphic]
}

pub(all) struct Pattern {
  pattern : &PatternTrait
  mut transform : Matrix
  mut inv_transform : Matrix
}
pub fn Pattern::new(&PatternTrait) -> Self
pub fn Pattern::pattern_at_shape(Self, Shape, Tuple, normal? : Tuple, uv? : (Double, Double)) -> Color
pub fn Pattern::set_pattern_transform(Self, Matrix) -> Unit
pub impl PatternTrait for Pattern
pub impl Eq for Pattern
pub impl Show for Pattern

pub(all) struct PlanarMapping {
}
pub impl Mapping for PlanarMapping
pub impl Eq for PlanarMapping
pub impl Show for PlanarMapping

pub(all) struct Plane {
}
pub impl Object for Plane
pub impl Eq for Plane
pub impl Show for Plane

pub(all) struct PosterizePattern {
  pattern : Pattern
  steps : Int
}
pub impl PatternTrait for PosterizePattern
pub impl Show for PosterizePattern

pub(all) struct Ray {
  origin : Tuple
  direction : Tuple
}
pub fn Ray::position(Self, Double) -> Tuple
pub fn Ray::transform(Self, Matrix) -> Self
pub impl Eq for Ray
pub impl Show for Ray

pub(all) struct RenderSettings {
  mut width : Int
  mut height : Int
  mut samples : Int
  mut max_bounces : Int
  mut background : Color
  mut divide : Int
  mut exposure : Double
}
pub impl Eq for RenderSettings
pub impl Show for RenderSettings

pub(all) enum Renderable {
  Object(&Object)
  Group(Group)
  Triangle(Triangle)
  SmoothTriangle(SmoothTriangle)
  CSG(CSG)
  TriangleUV(TriangleUV)
  SmoothTriangleUV(SmoothTriangleUV)
}
pub impl Show for Renderable

pub(all) struct RingPattern {
  colors : Array[Color]
}
pub fn RingPattern::to_string(Self) -> String
pub impl PatternTrait for RingPattern
pub impl Eq for RingPattern
pub impl Show for RingPattern

pub(all) struct SceneMetadata {
  name : String
  description : String
  version : String
}
pub impl Eq for SceneMetadata
pub impl Show for SceneMetadata

pub(all) struct Shape {
  object : Renderable
  mut material : Material
  mut material_layer : MaterialLayer?
  mut transform : Matrix
  mut inv_transform : Matrix
  mut parent : Shape?
  mut bounds : Bounds?
  id : UInt
}
pub fn Shape::add_child(Self, Self) -> Unit
pub fn Shape::bounds(Self) -> Bounds
pub fn Shape::children(Self) -> Array[Self]
pub fn Shape::clone(Self) -> Self
pub fn Shape::divide(Self, Int) -> Unit
pub fn Shape::includes_shape(Self, Self) -> Bool
pub fn Shape::intersect(Self, Ray) -> Intersections
pub fn Shape::local_intersect(Self, Ray) -> Intersections
pub fn Shape::local_normal_at(Self, Tuple, hit? : Intersection?) -> Tuple
pub fn Shape::new(Renderable) -> Self
pub fn Shape::new_csg(CSG) -> Self
pub fn Shape::new_group(Group) -> Self
pub fn Shape::new_object(&Object) -> Self
pub fn Shape::new_smooth_triangle(SmoothTriangle) -> Self
pub fn Shape::new_triangle(Triangle) -> Self
pub fn Shape::normal_at(Self, Tuple, hit? : Intersection?) -> Tuple
pub fn Shape::normal_to_world(Self, Tuple) -> Tuple
pub fn Shape::object_space_bounds(Self) -> Bounds
pub fn Shape::object_to_world(Self, Tuple) -> Tuple
pub fn Shape::parent_space_bounds(Self) -> Bounds
pub fn Shape::set_transform(Self, Matrix) -> Unit
pub fn Shape::world_normal_to_object(Self, Tuple) -> Tuple
pub fn Shape::world_to_object(Self, Tuple) -> Tuple
pub impl Eq for Shape
pub impl Show for Shape

pub(all) struct SmoothTriangle {
  p1 : Tuple
  p2 : Tuple
  p3 : Tuple
  n1 : Tuple
  n2 : Tuple
  n3 : Tuple
  e1 : Tuple
  e2 : Tuple
  bounds : Bounds
}
pub fn SmoothTriangle::bounds(Self) -> Bounds
pub fn SmoothTriangle::clone(Self) -> Self
pub fn SmoothTriangle::local_intersect(Self, Ray) -> Array[(Double, Double, Double)]
pub fn SmoothTriangle::local_normal_at(Self, Tuple, Intersection) -> Tuple
pub impl Eq for SmoothTriangle
pub impl Show for SmoothTriangle

pub(all) struct SmoothTriangleUV {
  p1 : Tuple
  p2 : Tuple
  p3 : Tuple
  n1 : Tuple
  n2 : Tuple
  n3 : Tuple
  uv1 : (Double, Double)
  uv2 : (Double, Double)
  uv3 : (Double, Double)
  uv1b : (Double, Double)?
  uv2b : (Double, Double)?
  uv3b : (Double, Double)?
  e1 : Tuple
  e2 : Tuple
  tangent_u : Tuple
  tangent_v : Tuple
  bounds : Bounds
}
pub fn SmoothTriangleUV::bounds(Self) -> Bounds
pub fn SmoothTriangleUV::clone(Self) -> Self
pub fn SmoothTriangleUV::local_intersect(Self, Ray) -> Array[(Double, Double, Double)]
pub fn SmoothTriangleUV::local_normal_at(Self, Tuple, Intersection) -> Tuple
pub impl Eq for SmoothTriangleUV
pub impl Show for SmoothTriangleUV

pub(all) struct Sphere {
}
pub impl Object for Sphere
pub impl Eq for Sphere
pub impl Show for Sphere

pub(all) struct SphericalMapping {
}
pub impl Mapping for SphericalMapping
pub impl Eq for SphericalMapping
pub impl Show for SphericalMapping

pub(all) struct StripePattern {
  colors : Array[Color]
}
pub fn StripePattern::to_string(Self) -> String
pub impl PatternTrait for StripePattern
pub impl Eq for StripePattern
pub impl Show for StripePattern

pub(all) struct Texture {
  canvas : Canvas
  mapping : &Mapping
}
pub impl PatternTrait for Texture
pub impl Eq for Texture
pub impl Show for Texture

pub(all) struct ThresholdPattern {
  pattern : Field
  threshold : Double
  low : Color
  high : Color
}
pub impl PatternTrait for ThresholdPattern
pub impl Show for ThresholdPattern

pub(all) struct Triangle {
  p1 : Tuple
  p2 : Tuple
  p3 : Tuple
  e1 : Tuple
  e2 : Tuple
  normal : Tuple
  bounds : Bounds
}
pub fn Triangle::bounds(Self) -> Bounds
pub fn Triangle::clone(Self) -> Self
pub fn Triangle::local_intersect(Self, Ray) -> Array[(Double, Double, Double)]
pub fn Triangle::local_normal_at(Self, Tuple) -> Tuple
pub impl Eq for Triangle
pub impl Show for Triangle

pub(all) struct TriangleUV {
  p1 : Tuple
  p2 : Tuple
  p3 : Tuple
  uv1 : (Double, Double)
  uv2 : (Double, Double)
  uv3 : (Double, Double)
  uv1b : (Double, Double)?
  uv2b : (Double, Double)?
  uv3b : (Double, Double)?
  e1 : Tuple
  e2 : Tuple
  normal : Tuple
  tangent_u : Tuple
  tangent_v : Tuple
  bounds : Bounds
}
pub fn TriangleUV::bounds(Self) -> Bounds
pub fn TriangleUV::clone(Self) -> Self
pub fn TriangleUV::local_intersect(Self, Ray) -> Array[(Double, Double, Double)]
pub fn TriangleUV::local_normal_at(Self, Tuple) -> Tuple
pub impl Eq for TriangleUV
pub impl Show for TriangleUV

pub(all) struct TriplanarPattern {
  pattern : Pattern
  scale : Double
  sharpness : Double
}
pub impl PatternTrait for TriplanarPattern
pub impl Show for TriplanarPattern

pub(all) struct Tuple {
  mut x : Double
  mut y : Double
  mut z : Double
  mut w : Double
}
pub fn Tuple::abs(Self) -> Self
pub fn Tuple::cross(Self, Self) -> Self
pub fn Tuple::div_scalar(Self, Double) -> Self
pub fn Tuple::dot(Self, Self) -> Double
pub fn Tuple::is_point(Self) -> Bool
pub fn Tuple::is_vector(Self) -> Bool
pub fn Tuple::magnitude(Self) -> Double
pub fn Tuple::mul_scalar(Self, Double) -> Self
pub fn Tuple::normalize(Self) -> Self
pub fn Tuple::op_div(Self, Self) -> Self
pub fn Tuple::op_get(Self, Int) -> Double
pub fn Tuple::op_set(Self, Int, Double) -> Unit
pub fn Tuple::reflect(Self, Self) -> Self
pub fn Tuple::to_string(Self) -> String
pub impl Add for Tuple
pub impl Eq for Tuple
pub impl Mul for Tuple
pub impl Neg for Tuple
pub impl Show for Tuple
pub impl Sub for Tuple

pub enum VectorDecoding {
  Unit01
  Signed
}
pub impl Eq for VectorDecoding
pub impl Show for VectorDecoding

pub(all) enum VoronoiMode {
  Distance
  Cells
  Edges
  Crackle
  F1
  F2
  F2MinusF1
}
pub impl Eq for VoronoiMode
pub impl Show for VoronoiMode

pub(all) struct VoronoiPattern {
  seed : Int
  scale : Double
  jitter : Double
  mode : VoronoiMode
  edge_scale : Double
}
pub impl PatternTrait for VoronoiPattern
pub impl Show for VoronoiPattern

pub(all) struct WarpPattern {
  base : Pattern
  warp : Field
  amplitude : Double
}
pub impl PatternTrait for WarpPattern
pub impl Show for WarpPattern

pub(all) struct WoodPattern {
  colors : Array[Color]
  seed : Int
  scale : Double
  octaves : Int
  lacunarity : Double
  gain : Double
  ring_frequency : Double
  turbulence : Double
}
pub impl PatternTrait for WoodPattern
pub impl Show for WoodPattern

pub(all) struct World {
  mut shapes : Array[Shape]
  mut lights : Array[Light]
  mut background : Color
  mut environment_map : Pattern?
}
pub fn World::color_at(Self, Ray, remaining? : Int) -> Color
pub fn World::intersect_world(Self, Ray) -> Intersections
pub fn World::is_shadowed(Self, Tuple, Tuple) -> Bool
pub fn World::reflected_color(Self, Computations, Int) -> Color
pub fn World::refracted_color(Self, Computations, Int) -> Color
pub fn World::shade_hit(Self, Computations, remaining? : Int) -> Color

// Type aliases

// Traits
pub(open) trait Mapping : Show {
  map(Self, Tuple) -> (Double, Double)
}

pub(open) trait Object : Show {
  local_intersect(Self, Ray) -> Array[Double]
  local_normal_at(Self, Tuple) -> Tuple
  bounds(Self) -> Bounds
  clone(Self) -> &Object
}

pub(open) trait PatternTrait : Show {
  pattern_at(Self, Tuple) -> Color
  uv_at(Self, Double, Double) -> Color
  pattern_at_with_info(Self, Tuple, Tuple, (Double, Double)?) -> Color
  clone(Self) -> Pattern
}

